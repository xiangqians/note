// DB
// https://pkg.go.dev/github.com/mattn/go-sqlite3
// @author xiangqian
// @date 20:10 2022/12/21
package db

import (
	"database/sql"
	"fmt"
	_ "github.com/mattn/go-sqlite3"
	typ_page "note/src/typ/page"
	util_str "note/src/util/str"
	"reflect"
	"strings"
)

// Page 分页查询
func Page[T any](dsn string, pageReq typ_page.PageReq, sql string, args ...any) (typ_page.Page[T], error) {
	// page
	current := pageReq.Current
	size := pageReq.Size
	page := typ_page.Page[T]{
		Current: current,
		Size:    size,
	}

	// db
	db := Get(dsn)
	defer db.Close()

	// open
	err := db.Open()
	if err != nil {
		return page, err
	}

	// begin
	err = db.Begin()
	if err != nil {
		return page, err
	}
	defer db.Commit()

	// count
	countSql := fmt.Sprintf("SELECT COUNT(1) %s", sql[strings.Index(sql, "FROM"):])
	if strings.Contains(countSql, "GROUP BY") {
		countSql = fmt.Sprintf("SELECT COUNT(1) FROM (%s) r", countSql)
	}
	total, _, err := RowsMapper[int64](db.Qry(countSql, args...))
	if err != nil {
		return page, err
	}
	if total == 0 {
		return page, nil
	}

	// set total & pages
	page.Total = total
	pages := total / int64(size)
	if total%int64(size) != 0 {
		pages += 1
	}
	page.Pages = pages

	// [offset,] rows
	offset := (current - 1) * int64(size)
	rows := size
	sql = fmt.Sprintf("%s LIMIT %v, %v", sql, offset, rows)

	// query
	data, count, err := RowsMapper[[]T](db.Qry(sql, args...))
	if err != nil {
		return page, err
	}
	if count > 0 {
		// 不赋予指针数据，以访发生逃逸
		//page.Data = &data
		page.Data = data
	}

	return page, nil
}

func Qry[T any](dsn string, sql string, args ...any) (T, int64, error) {
	var t T

	// db
	db := Get(dsn)
	defer db.Close()

	// open
	err := db.Open()
	if err != nil {
		return t, 0, err
	}

	// begin
	err = db.Begin()
	if err != nil {
		return t, 0, err
	}
	defer db.Commit()

	// qry & mapper
	return RowsMapper[T](db.Qry(sql, args...))
}

func Upd(dsn string, sql string, args ...any) (int64, error) {
	return exec(dsn, func(db Db, sql string, args ...any) (int64, error) {
		return db.Upd(sql, args...)
	}, sql, args...)
}

func Del(dsn string, sql string, args ...any) (int64, error) {
	return exec(dsn, func(db Db, sql string, args ...any) (int64, error) {
		return db.Del(sql, args...)
	}, sql, args...)
}

func Add(dsn string, sql string, args ...any) (int64, error) {
	return exec(dsn, func(db Db, sql string, args ...any) (int64, error) {
		return db.Add(sql, args...)
	}, sql, args...)
}

func exec(dsn string, f func(db Db, sql string, args ...any) (int64, error), sql string, args ...any) (int64, error) {
	// db
	db := Get(dsn)
	defer db.Close()

	// open
	err := db.Open()
	if err != nil {
		return 0, err
	}

	// begin
	err = db.Begin()
	if err != nil {
		return 0, err
	}
	defer db.Commit()

	// func
	return f(db, sql, args...)
}

// Get 获取db
// dsn: Data Source Name
func Get(dsn string) Db {
	return &DbImpl{
		driver: "sqlite3",
		dsn:    dsn,
	}
}

// defer的作用是把defer关键字之后的函数执行压入一个栈中延迟执行，多个defer的执行顺序是后进先出LIFO

type Db interface {
	// Open 打开db
	Open() error

	// Begin 开启事务
	Begin() error

	// Add 新增
	// returns the integer generated by the database in response to a command.
	// Typically this will be from an "auto increment" column when inserting a new row.
	// Not all databases support this feature, and the syntax of such statements varies.
	// return insertId
	Add(sql string, args ...any) (int64, error)

	// Del 删除
	// returns the number of rows affected by an update, insert, or delete. Not every database or database driver may support this.
	// return affect
	Del(sql string, args ...any) (int64, error)

	// Upd 更新
	// returns the number of rows affected by an update, insert, or delete. Not every database or database driver may support this.
	Upd(sql string, args ...any) (int64, error)

	// Qry 查询
	Qry(sql string, args ...any) (*sql.Rows, error)

	// Commit 提交事务
	Commit() error

	// Rollback 回滚事务
	Rollback() error

	// Close 关闭资源
	Close() error
}

// DbImpl db implement
type DbImpl struct {
	driver string  // driver
	dsn    string  // Data Source Name
	db     *sql.DB // db
	tx     *sql.Tx // tx
	err    error   // error
}

func (db *DbImpl) Open() error {
	db.db, db.err = sql.Open(db.driver, db.dsn)
	return db.err
}

func (db *DbImpl) Begin() error {
	if db.err != nil {
		return db.err
	}

	db.tx, db.err = db.db.Begin()
	return db.err
}

func (db *DbImpl) Add(sql string, args ...any) (int64, error) {
	res, err := db.tx.Exec(sql, args...)
	if err != nil {
		return 0, err
	}
	return res.LastInsertId()
}

func (db *DbImpl) exec(sql string, args ...any) (int64, error) {
	if db.err != nil {
		return 0, db.err
	}

	res, err := db.tx.Exec(sql, args...)
	if err != nil {
		return 0, err
	}

	return res.RowsAffected()
}

func (db *DbImpl) Del(sql string, args ...any) (int64, error) {
	return db.exec(sql, args...)
}

func (db *DbImpl) Upd(sql string, args ...any) (int64, error) {
	return db.exec(sql, args...)
}

func (db *DbImpl) Qry(sql string, args ...any) (*sql.Rows, error) {
	return db.tx.Query(sql, args...)
}

func (db *DbImpl) Commit() error {
	if db.err == nil && db.tx != nil {
		db.err = db.tx.Commit()
	}
	return db.err
}

func (db *DbImpl) Rollback() error {
	if db.err == nil && db.tx != nil {
		db.err = db.tx.Rollback()
	}
	return db.err
}

func (db *DbImpl) Close() error {
	if db.db != nil {
		db.err = db.db.Close()
	}
	return db.err
}

// RowsMapper 行映射
// 支持：
// 1、基本数据类型映射
// 2、结构体类型映射
// 3、基本数据类型/结构体 切片映射
func RowsMapper[T any](rows *sql.Rows, err error) (T, int64, error) {
	var t T

	if err != nil {
		return t, 0, err
	}
	defer rows.Close()

	// 获取数据库字段名称集
	cols, err := rows.Columns()
	if err != nil {
		return t, 0, err
	}

	var count int64
	rflVal := reflect.ValueOf(&t).Elem()
	rflTyp := rflVal.Type()
	switch rflTyp.Kind() {
	// 结构体
	case reflect.Struct:
		if rows.Next() {
			count++
			dest := getDest(cols, rflTyp, rflVal)
			err = rows.Scan(dest...)
		}

	// 切片
	case reflect.Slice:
		// 创建切片
		// len 0, cap ?
		i := reflect.MakeSlice(rflTyp, 1, 1).Interface()
		t, _ = i.(T)
		rflVal = reflect.ValueOf(&t).Elem()

		// 切片长度（Len）
		l := rflVal.Len()
		// 获取切片元素
		eRflVal := rflVal.Index(0) // 获取切片第一个元素值（Value）
		eRflType := eRflVal.Type() // 切片元素类型
		e := eRflVal.Interface()   // 切片元素值
		// 切片元素类型
		switch eRflVal.Kind() {
		// Map
		case reflect.Map:
			// 尚未实现
			panic("暂不支持map切片")

		// 结构体切片、基本类型切片
		default:
			// 元素反射值
			idx := 0
			for rows.Next() {
				count++
				if idx < l {
					eRflVal = rflVal.Index(idx).Addr().Elem()
				} else {
					// reflect.New(): 返回指定类型的指针，该指针指向新创建的对象，返回指定类型指针的反射对象（Value结构体）
					e = reflect.New(eRflType).Interface()
					eRflVal = reflect.ValueOf(e).Elem()
				}
				dest := getDest(cols, eRflType, eRflVal)
				err = rows.Scan(dest...)
				if err != nil {
					return t, count, err
				}

				// 切片（slice）扩容
				if idx >= l {
					oldRflVal := rflVal
					rflVal = reflect.Append(rflVal, eRflVal)
					oldRflVal.Set(rflVal)
					rflVal = oldRflVal
				}
				idx++
			}
		}

	// Map
	case reflect.Map:
		//reflect.MakeMap(): 创建map
		panic("暂不支持map数据")

	// 普通指针类型
	default:
		if rows.Next() {
			count++
			err = rows.Scan(&t)
		}
	}

	return t, count, err
}

func getDest(cols []string, rflType reflect.Type, rflVal reflect.Value) []any {
	// kind
	switch rflType.Kind() {
	// 基本数据类型
	case reflect.Int:
		fallthrough // 执行穿透
	case reflect.Int8:
		fallthrough
	case reflect.Int16:
		fallthrough
	case reflect.Int32:
		fallthrough
	case reflect.Int64:
		fallthrough
	case reflect.String:
		return getBasicDest(cols, rflType, rflVal)

	// 结构体
	case reflect.Struct:
		return getStructDest(cols, rflType, rflVal)

	// default
	default:
		panic(fmt.Sprintf("%s '%s' %s", "不支持此类型", rflType.Kind().String(), "dest"))
	}
}

func getBasicDest(cols []string, rflType reflect.Type, rflVal reflect.Value) []any {
	// dest
	dest := make([]any, len(cols))

	// addr
	dest[0] = rflVal.Addr().Interface()

	return dest
}

func getStructDest(cols []string, rflType reflect.Type, rflVal reflect.Value) []any {
	// dest
	dest := make([]any, len(cols))

	// field
	for fi, fl := 0, rflType.NumField(); fi < fl; fi++ {
		typeField := rflType.Field(fi)

		// 兼容 FieldAlign() int （如果是struct字段，对齐后占用的字节数）
		if typeField.Type.Kind() == reflect.Struct {
			for sfi, sfl := 0, typeField.Type.NumField(); sfi < sfl; sfi++ {
				setStructDest(cols, &dest, typeField.Type.Field(sfi), rflVal)
			}
		} else {
			setStructDest(cols, &dest, typeField, rflVal)
		}
	}

	return dest
}

func setStructDest(cols []string, dest *[]any, typeField reflect.StructField, rflVal reflect.Value) {
	name := typeField.Tag.Get("sql")
	if name == "" {
		name = util_str.NameHumpToUnderline(typeField.Name)
	}
	for ci, col := range cols {
		if col == name {
			valField := rflVal.FieldByName(typeField.Name)
			if valField.CanAddr() {
				(*dest)[ci] = valField.Addr().Interface()
			}
			break
		}
	}
}
